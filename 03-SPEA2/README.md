# SPEA2算法求解Schaffer问题文档

## 概述

本文件(`spea2_sch.py`)实现了SPEA2（Strength Pareto Evolutionary Algorithm 2）多目标优化算法，用于求解经典的Schaffer双目标优化问题。

## 问题定义

### Schaffer问题
Schaffer问题是一个经典的双目标优化测试问题：

- **决策变量**: x ∈ [-1000, 1000]（代码中限制为[-5, 5]）
- **目标函数**:
  - f₁(x) = x²
  - f₂(x) = (x-2)²
- **理论最优解范围**: x ∈ [0, 2]

## 核心类和组件

### 1. SchafferProblem类
定义Schaffer问题的参数和评估函数：
- `n_var`: 决策变量数量（1个）
- `n_obj`: 目标函数数量（2个）
- `xl`, `xu`: 变量上下界
- `evaluate(x)`: 计算目标函数值
- `is_in_optimal_range(x)`: 检查解是否在理论最优范围内

### 2. Individual类
表示进化算法中的个体：
- `x`: 决策变量
- `f`: 目标函数值
- `strength`: 强度值（SPEA2特有）
- `raw_fitness`: 原始适应度
- `density`: 密度值
- `fitness`: 总适应度值

### 3. SPEA2类
SPEA2算法的主要实现：

#### 主要参数
- `pop_size`: 种群大小（默认100）
- `archive_size`: 归档集大小（默认100）
- `n_gen`: 进化代数（默认200）
- `crossover_prob`: 交叉概率（默认0.9）
- `crossover_eta`: SBX交叉参数（默认15）
- `mutation_eta`: 多项式变异参数（默认20）

#### 核心方法

##### 适应度计算
SPEA2的适应度计算包含三个步骤：
1. **强度值计算**: 每个个体支配的其他个体数量
2. **原始适应度**: 支配当前个体的所有个体的强度值之和
3. **密度值**: 基于k-最近邻的密度估计
4. **总适应度**: 原始适应度 + 密度值

##### 环境选择
1. 选择适应度值小于1的个体（非支配解）
2. 如果归档集不足，从被支配解中补充
3. 如果归档集过大，移除距离最近的个体

##### 遗传操作
- **选择**: 二元锦标赛选择
- **交叉**: 模拟二进制交叉（SBX）
- **变异**: 多项式变异

## 算法流程

1. **初始化**: 随机生成初始种群
2. **主循环**（重复n_gen代）:
   - 合并种群和归档集
   - 计算适应度
   - 环境选择更新归档集
   - 二元锦标赛选择
   - 交叉和变异产生子代
   - 评估子代
3. **输出**: 返回归档集中的解

## 性能评估

### 评估指标
1. **IGD（Inverted Generational Distance）**: 衡量解集到理论帕累托前沿的收敛性
2. **Spread**: 衡量解集的分布均匀性

### 可视化
程序生成帕累托前沿图，包含：
- SPEA2算法找到的解集（蓝色空心圆）
- 理论帕累托前沿（红色实线）

## 使用方法

```python
# 创建问题实例
problem = SchafferProblem(xl=-5, xu=5)

# 创建SPEA2算法实例
spea2 = SPEA2(problem, pop_size=50, archive_size=50, n_gen=50)

# 运行算法
X, F = spea2.run()
```

## 输出结果

程序输出包括：
1. 性能指标（IGD和Spread值）
2. 前10个解的决策变量和目标函数值
3. 在理论最优范围内的解的比例
4. 帕累托前沿可视化图（保存为PNG文件）

## 理论分析

对于Schaffer问题：
- 当x = 0时，f₁达到最小值0，f₂达到最大值4
- 当x = 2时，f₁达到最大值4，f₂达到最小值0
- 帕累托最优解在x ∈ [0, 2]范围内形成连续的前沿


## 依赖库

- `numpy`: 数值计算
- `matplotlib`: 可视化
- `random`: 随机数生成
- `typing`: 类型提示

## 文件输出

- `spea2_sch_pareto.png`: 帕累托前沿可视化图
